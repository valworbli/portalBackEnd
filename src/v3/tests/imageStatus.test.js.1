/* eslint max-len: 0 */
const HttpStatus = require('http-status-codes');
const request = require('supertest');
const chai = require('chai'); // eslint-disable-line import/newline-after-import
const expect = chai.expect;
const assert = chai.assert;
const app = require('../../../worbli-api');
const logger = require('../components/logger')(module);
const clientio = require('socket.io-client');
const Const = require('../defs/const');

require('dotenv').config();
const Promise = require('bluebird');
const Users = require('../models/schemas/users');
const mongoose = require('mongoose');
mongoose.Promise = Promise;

chai.config.includeStack = true;

const baseTestUrl = '/api/v3/mobile/';
const defUser = new Users({
  email: 'test319@example.com',
  password: 'bozoPass!',
  agreed_terms: true,
  agreed_marketing: false,
  verify_token: 'cc2b039697793f4f38aa908f07fd2974',
});

const _saveDefUser = function(done) {
  defUser.save(function(err, user) {
    expect(err).to.be.null;
    expect(user.verify_token).to.equal(defUser.verify_token);
    done();
    // user.verify_token = '';
    // user.save(function(err, user) {
    //   expect(err).to.be.null;
    //   done();
    // });
  });
};

function timeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

describe('## Mobile', function() {
  this.timeout(15000);
  const testUrl = baseTestUrl + 'shortcode/';
  let jwtToken = ''; let mobilejwtToken = ''; let shortcode = 0;
  let socket = undefined;
  let completeDone = false;
  let myDone = undefined;

  describe(`# POST ${testUrl}`, () => {
    let mustDisconnect = false;
    before(function(done) {
      if (mongoose.connection.readyState === 0) {
        mustDisconnect = true;
        mongoose.connect(`mongodb://${process.env.DB_HOST}/${process.env.DB_NAME}`,
            {useNewUrlParser: true}, function(err) {
              expect(err).to.be.null;
              _saveDefUser(done);
            });
      } else {
        _saveDefUser(done);
      }
    });

    after(function(done) {
      Users.deleteOne({email: defUser.email}, function(err) {
        if (err) {
          logger.error(`Error deleting ${defUser.email}: ${err}`);
        } else {
          logger.info(`Deleted ${defUser.email}`);
        }

        if (mustDisconnect) {
          mongoose.disconnect(done);
        } else {
          done();
        }
      });
    });

    it('verifies the user - should return 200 and data true', (done) => {
      request(app)
          .post('/api/v3/user/verify/')
          .auth()
          .set('Accept', 'application/json')
          .send({token: defUser.verify_token})
          .expect(HttpStatus.OK)
          .then((res) => {
            expect({data: true});
            done();
          })
          .catch(done);
    });

    it('logs in - should return 200 and true', (done) => {
      request(app)
          .post('/api/v3/visitor/signin/')
          .set('Accept', 'application/json')
          .send({email: defUser.email, password: 'bozoPass!'})
          .expect(HttpStatus.OK)
          .then((res) => {
            expect(res.body.jwt).to.be.not.undefined;
            expect({data: true});
            jwtToken = res.body.jwt;
            done();
          })
          .catch(done);
    });

    it('gets a shortcode - should return 200 and data true', (done) => {
      request(app)
          .get(testUrl)
          .set('Accept', 'application/json')
          .set('Authorization', `Bearer ${jwtToken}`)
          .expect(HttpStatus.OK)
          .then((res) => {
            assert(res.body.data === true, 'Err data is not true');
            shortcode = Number(res.body.shortcode);
            done();
          })
          .catch(done);
    });

    const onInitialMissingImagesIncomplete = function(data) {
      socket.removeListener(Const.SOCKET_MISSING_IMAGES, onInitialMissingImagesIncomplete);
      logger.info('onInitialMissingImagesIncomplete: ' + JSON.stringify(data));

      assert(data.completed === false, 'Err completed is not false');
      assert(data.data === true, 'Err data is not true');
      assert(data.country === '', 'Err country is not empty');
      assert(data.files.length === 0, 'Err files is not empty');
      // while (!myDone) {
      //   logger.warn('onInitialMissingImagesIncomplete: Waiting for myDone to be set...');
      //   await timeout(100);
      // }
    };

    const onInitialUserStateIncomplete = function(data) {
      socket.removeListener(Const.SOCKET_USER_GET_STATE, onInitialUserStateIncomplete);
      logger.info('onInitialUserStateIncomplete: ' + JSON.stringify(data));

      assert(data.data === true, 'Err data is not true');
      assert(data.status !== undefined, 'Err data.status is undefined');
      assert(data.status.status === 'created', 'Err status.created is not false');
      assert(data.status.errored === false, 'Err status.errored is not false');
      let done = myDone;
      myDone = undefined;
      done();
    };

    const onAllMissingImagesIncomplete = function(data) {
      socket.removeListener(Const.SOCKET_MISSING_IMAGES, onAllMissingImagesIncomplete);
      logger.info('onAllMissingImagesIncomplete: ' + JSON.stringify(data));
      const files = JSON.parse(data.files);
      assert(data.completed === false, 'Err completed is not false');
      assert(data.data === true, 'Err data is not true');
      assert(data.country === 'GBR', 'Err country is not GBR');
      assert(files.length > 0, 'Err files is empty');
      assert(files[0].value === 'national_identity_card_reverse', 'Err files[0] is not national_identity_card_reverse');
      assert(files[0].uploaded === false, 'Err files[0].uploaded is not false');
      let done = myDone;
      myDone = undefined;
      done();
    };

    const onTwoMissingImagesIncomplete = function(data) {
      socket.removeListener(Const.SOCKET_MISSING_IMAGES, onTwoMissingImagesIncomplete);
      logger.info('onTwoMissingImagesIncomplete: ' + JSON.stringify(data));
      const files = JSON.parse(data.files);
      assert(data.completed === false, 'Err completed is not false');
      assert(data.data === true, 'Err data is not true');
      assert(data.country === 'GBR', 'Err country is not empty');
      assert(files.length > 0, 'Err files is empty');
      assert(files[0].value === 'national_identity_card_reverse', 'Err files[0] is not national_identity_card_reverse');
      assert(files[0].uploaded === true, 'Err files[0].uploaded is not false');
      assert(files[1].value === 'national_identity_card', 'Err files[1] is not national_identity_card');
      assert(files[1].uploaded === false, 'Err files[1].uploaded is not false');
      let done = myDone;
      myDone = undefined;
      done();
    };

    const onBadSelfieMissingImagesIncomplete = function(data) {
      socket.removeListener(Const.SOCKET_MISSING_IMAGES, onBadSelfieMissingImagesIncomplete);
      logger.info('onBadSelfieMissingImagesIncomplete: ' + JSON.stringify(data));
      const files = JSON.parse(data.files);
      assert(data.completed === false, 'Err completed is not false');
      assert(data.data === true, 'Err data is not true');
      assert(data.country === 'GBR', 'Err country is not empty');
      assert(files.length > 0, 'Err files is empty');
      assert(files[0].value === 'national_identity_card_reverse', 'Err files[0] is not national_identity_card_reverse');
      assert(files[0].uploaded === true, 'Err files[0].uploaded is not false');
      assert(files[1].value === 'national_identity_card', 'Err files[1] is not national_identity_card');
      assert(files[1].uploaded === false, 'Err files[0].uploaded is not false');
      assert(files[2].value === 'selfie', 'Err files[2] is not selfie');
      assert(files[2].uploaded === false, 'Err files[2].uploaded is not false');
      assert(files[2].error === 'no face detected', 'Err files[2].error is not equal to \'no face detected\'');
      assert(files[2].deviceId === 111111, 'Err files[2].deviceId is not 111111');
      let done = myDone;
      myDone = undefined;
      done();
    };

    it('SOCKET: connects', (done) => {
      socket = clientio(`http://localhost:9020`, {
        autoConnect: true,
        reconnection: false,
        path: `${process.env.SOCKET_PATH}`,
        query: {
          jwt: jwtToken,
        },
      });
      socket.on('connect', () => {
        logger.info('SOCKET connected!');
      });

      myDone = done;
      socket.on(Const.SOCKET_MISSING_IMAGES, onInitialMissingImagesIncomplete);
      socket.on(Const.SOCKET_USER_GET_STATE, onInitialUserStateIncomplete);
    });

    it('sends files and a country - should return 200 and data true', function(done) {
      myDone = done;
      socket.on(Const.SOCKET_MISSING_IMAGES, onAllMissingImagesIncomplete);
      request(app)
        .post(baseTestUrl + 'files/')
        .set('Accept', 'application/json')
        .set('Authorization', `Bearer ${jwtToken}`)
        .send({country: 'GBR', files:
        '[{\'value\': \'national_identity_card_reverse\', \'label\': \'national identity card reverse\'}, {\'value\': \'national_identity_card\', \'label\': \'national identity card\'}]'})
        .expect(HttpStatus.OK)
        .then((res) => {
          assert(res.body.data === true, 'Err data is not true');
          Users.findOne({email: defUser.email}, function(err, user) {
            assert(Boolean(err) === false, 'Err could not retrieve the user from the DB post-test');
            assert(user.shortcodeData.country === 'GBR', 'Err the stored country DOES NOT match the submitted one');
            assert(user.shortcodeData.files ===
            '[{\'value\': \'national_identity_card_reverse\', \'label\': \'national identity card reverse\'}, {\'value\': \'national_identity_card\', \'label\': \'national identity card\'}]',
            'Err the stored document DOES NOT match the submitted one');
            // done() will be called by onAllMissingImagesIncomplete
          });
        }).catch(done);
    });

    it('authenticates with a valid shortcode - should return 200 and data true', (done) => {
      myDone = done;
      socket.on(Const.SOCKET_MISSING_IMAGES, onAllMissingImagesIncomplete);
      request(app)
          .post(testUrl)
          .set('Accept', 'application/json')
          .send({shortcode: shortcode})
          .expect(HttpStatus.OK)
          .then((res) => {
            assert(res.body.data === true, 'Err data is not true');
            assert(res.body.jwt !== undefined, 'Err No JWT was returned');
            mobilejwtToken = res.body.jwt;
            // done() will be called by onAllMissingImagesIncomplete
          }).catch(done);
    });

    it('uploads a single image - should return 200 and data true', (done) => {
      myDone = done;
      socket.on(Const.SOCKET_MISSING_IMAGES, onTwoMissingImagesIncomplete);
      request(app)
        .post('/api/v3/identity/image/')
        .set('Accept', 'application/json')
        .set('Authorization', `Bearer ${mobilejwtToken}`)
        .attach('111111_BGR_national_identity_card_reverse', 'src/samples/images/sampleID-back.jpg')
        .expect(HttpStatus.OK)
        .then((res) => {
          expect({data: true});
          // done() will be called by onTwoMissingImagesIncomplete
        }).catch(done);
    });

    it('uploads a BAD SELFIE - should return 200 and data true', (done) => {
      myDone = done;
      socket.on(Const.SOCKET_MISSING_IMAGES, onBadSelfieMissingImagesIncomplete);
      request(app)
        .post('/api/v3/identity/image/')
        .set('Accept', 'application/json')
        .set('Authorization', `Bearer ${mobilejwtToken}`)
        .attach('111111_BGR_selfie', 'src/samples/images/double_selfie.jpg')
        .expect(HttpStatus.OK)
        .then((res) => {
          expect({data: true});
          // done() will be called by onBadSelfieMissingImagesIncomplete
        }).catch(done);
    });
  });
});
